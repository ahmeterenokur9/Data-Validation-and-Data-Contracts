<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>İnteraktif Eğitim: Proje Kodlama Pratiği</title>
    <!-- Modern Font ve İkonlar -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-color: #2c2c2c;
            --text-color: #f0f0f0;
            --primary-color: #4ecca3;
            --secondary-color: #3b3b3b;
            --border-color: #444;
            --error-color: #ff6b6b;
            --success-color: #51cf66;
            --hint-color: #f1c40f;
            --fix-color: #3498db;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 2rem;
            margin-bottom: 2rem;
        }
        header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        header p {
            font-size: 1.2rem;
            color: #ccc;
        }
        .challenge-card {
            background-color: var(--card-color);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .challenge-card h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-top: 0;
        }
        textarea.code-editor {
            width: 100%;
            min-height: 150px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Source Code Pro', monospace;
            font-size: 1em;
            padding: 1rem;
            box-sizing: border-box;
            resize: vertical;
        }
        .button-group {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        button {
            background-color: var(--primary-color);
            color: #111;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        button:hover {
            background-color: #65d6b3;
        }
        button:active {
            transform: scale(0.98);
        }
        button.hint-btn {
            background-color: var(--hint-color);
        }
        button.hint-btn:hover {
            background-color: #f39c12;
        }
        button.fix-line-btn {
            background-color: var(--fix-color);
        }
        button.fix-line-btn:hover {
             background-color: #5dade2;
        }
        button.show-answer-btn {
            background-color: var(--secondary-color);
            color: var(--text-color);
        }
        button.show-answer-btn:hover {
            background-color: #555;
        }
        .feedback, .hint {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 6px;
            display: none;
            border-left: 5px solid;
        }
        .feedback.success {
            background-color: rgba(81, 207, 102, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
        }
        .feedback.error {
            background-color: rgba(255, 107, 107, 0.1);
            border-color: var(--error-color);
            color: var(--error-color);
        }
        .hint {
            background-color: rgba(241, 196, 15, 0.1);
            border-color: var(--hint-color);
            color: var(--hint-color);
        }
        .explanation {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: rgba(78, 204, 163, 0.05);
            border: 1px solid rgba(78, 204, 163, 0.2);
            border-radius: 6px;
            display: none;
        }
        .explanation h4 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .explanation ul {
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="ph-bold ph-code-block"></i> İnteraktif Kodlama Eğitimi</h1>
            <p>Projenin temel kod bloklarını yazarak ve düzenleyerek öğrenin.</p>
        </header>

        <main>
            <!-- Challenge 1: FastAPI Endpoint -->
            <div class="challenge-card">
                <h3>Alıştırma 1: FastAPI GET Endpoint'i Oluşturma</h3>
                <p><strong>Göreviniz:</strong> <code>/api/mqtt-settings</code> adresine gelen <code>GET</code> isteklerini karşılayan ve <code>config.json</code>'dan okuduğu ayarları önbellekleme kapalı olarak döndüren fonksiyonun tamamını yazın.</p>
                <textarea id="challenge1" class="code-editor" rows="5" placeholder="@app.get(...)
async def ..."></textarea>
                <div class="button-group">
                    <button onclick="checkAnswer('challenge1')"><i class="ph ph-check-circle"></i> Cevabı Kontrol Et</button>
                    <button class="hint-btn" onclick="getHint('challenge1')"><i class="ph ph-lightbulb"></i> İpucu Al</button>
                    <button class="fix-line-btn" onclick="fixLine('challenge1')"><i class="ph ph-life-preserver"></i> Satırı Düzelt</button>
                    <button class="show-answer-btn" onclick="showAnswer('challenge1')"><i class="ph ph-text-aa"></i> Cevabı Göster</button>
                </div>
                <div id="hint1" class="hint"></div>
                <div id="feedback1" class="feedback"></div>
                <div id="explanation1" class="explanation">
                    <h4>Harika! İşte Kodun Açıklaması:</h4>
                    <p>Bu, projedeki bir endpoint'in tam halidir. Önemli noktalar:</p>
                    <ul>
                        <li><code>@app.get(...)</code>: Fonksiyonu belirli bir URL ve metoda bağlar.</li>
                        <li><code>config = read_config()</code>: Ayarları diskten okur.</li>
                        <li><code>return JSONResponse(...)</code>: Standart bir yanıt yerine, içine özel başlık (header) ekleyebileceğimiz bir <code>JSONResponse</code> döndürüyoruz.</li>
                        <li><code>headers={"Cache-Control": "no-store"}</code>: Tarayıcıya bu yanıtı asla önbelleğine almamasını söyler. Bu, dinamik ayarlarda çok önemlidir çünkü tarayıcının eski, önbelleğe alınmış verileri kullanmasını engeller.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Challenge 2: Pandera Validation -->
            <div class="challenge-card">
                <h3>Alıştırma 2: Pandera ile Veri Doğrulama</h3>
                <p><strong>Göreviniz:</strong> Gelen bir mesajı doğrulayan, başarılı olursa "validated" konusuna, başarısız olursa "failed" konusuna hata raporuyla birlikte yayınlayan <code>try-except</code> bloğunun tam halini yazın.</p>
                <textarea id="challenge2" class="code-editor" rows="8" placeholder="try:
    ...
except ...:
    ..."></textarea>
                <div class="button-group">
                    <button onclick="checkAnswer('challenge2')"><i class="ph ph-check-circle"></i> Cevabı Kontrol Et</button>
                    <button class="hint-btn" onclick="getHint('challenge2')"><i class="ph ph-lightbulb"></i> İpucu Al</button>
                    <button class="fix-line-btn" onclick="fixLine('challenge2')"><i class="ph ph-life-preserver"></i> Satırı Düzelt</button>
                    <button class="show-answer-btn" onclick="showAnswer('challenge2')"><i class="ph ph-text-aa"></i> Cevabı Göster</button>
                </div>
                <div id="hint2" class="hint"></div>
                <div id="feedback2" class="feedback"></div>
                <div id="explanation2" class="explanation">
                    <h4>Mükemmel! Kodun Kalbini Yazdınız.</h4>
                    <p>Bu <code>try-except</code> bloğu, projenin veri doğrulama mantığının temelidir.</p>
                    <ul>
                        <li><code>try</code> bloğunda, veri doğrulanır. Başarılı olursa, orijinal mesaj <code>self.client.publish</code> ile "validated" konusuna yayınlanır. <code>retain=True</code> bayrağı, bu mesajın bu konuya abone olan herkese anında gönderilmesini sağlar.</li>
                        <li><code>except</code> bloğu, doğrulama başarısız olduğunda çalışır. Hata raporu oluşturulur ve bu rapor "failed" konusuna yayınlanır. Bu sayede hatalı veri kaybolmaz ve neden hatalı olduğu analiz edilebilir.</li>
                    </ul>
                </div>
            </div>

            <!-- Challenge 3: Fetch POST Request -->
            <div class="challenge-card">
                <h3>Alıştırma 3: JavaScript ile API İsteği</h3>
                <p><strong>Göreviniz:</strong> Yönetim panelindeki kaydetme fonksiyonunun, hem konu eşleştirmelerini hem de MQTT ayarlarını sunucuya gönderen <code>try-catch</code> bloğunun tamamını yazın.</p>
                <textarea id="challenge3" class="code-editor" rows="7" placeholder="try {
    ...
} catch (error) {
    ...
}"></textarea>
                <div class="button-group">
                    <button onclick="checkAnswer('challenge3')"><i class="ph ph-check-circle"></i> Cevabı Kontrol Et</button>
                    <button class="hint-btn" onclick="getHint('challenge3')">İpucu Al</button>
                    <button class="fix-line-btn" onclick="fixLine('challenge3')"><i class="ph ph-life-preserver"></i> Satırı Düzelt</button>
                    <button class="show-answer-btn" onclick="showAnswer('challenge3')"><i class="ph ph-text-aa"></i> Cevabı Göster</button>
                </div>
                <div id="hint3" class="hint"></div>
                <div id="feedback3" class="feedback"></div>
                <div id="explanation3" class="explanation">
                    <h4>Çok Başarılı! Frontend-Backend Bağlantısı.</h4>
                    <p>Bu kod bloğu, yönetim panelindeki "Kaydet" butonunun arkasındaki mantığın tam halidir.</p>
                    <ul>
                        <li><code>try</code> bloğu, sunucuya yapılan API isteklerini içerir. <code>await</code> kelimesi, bir isteğin bitmesini beklemeden diğerine geçmemesini sağlar. Bu, işlemlerin doğru sırada yapılmasını garanti eder.</li>
                         <li>İki ayrı <code>apiCall</code> (veya <code>fetch</code>) ile iki farklı endpoint'e istek atılır: biri konu eşleştirmeleri, diğeri MQTT ayarları için.</li>
                        <li>İstekler başarılı olursa, kullanıcıya bir başarı mesajı gösterilir.</li>
                        <li><code>catch (error)</code> bloğu, ağ hatası veya sunucudan gelen bir hata durumunda çalışır ve kullanıcıya neyin yanlış gittiğini bildirir.</li>
                    </ul>
                </div>
            </div>

            <!-- Challenge 4: WebSocket onmessage -->
            <div class="challenge-card">
                <h3>Alıştırma 4: WebSocket ile Anlık Güncelleme</h3>
                <p><strong>Göreviniz:</strong> Dashboard'un (<code>app.js</code>), sunucudan gelen konfigürasyon güncelleme mesajını dinleyen ve buna göre kendini yeniden başlatan WebSocket olay yöneticisinin tam halini yazın.</p>
                <textarea id="challenge4" class="code-editor" rows="7" placeholder="ws.onmessage = (event) => {
    ...
};"></textarea>
                <div class="button-group">
                    <button onclick="checkAnswer('challenge4')"><i class="ph ph-check-circle"></i> Cevabı Kontrol Et</button>
                    <button class="hint-btn" onclick="getHint('challenge4')">İpucu Al</button>
                    <button class="fix-line-btn" onclick="fixLine('challenge4')"><i class="ph ph-life-preserver"></i> Satırı Düzelt</button>
                    <button class="show-answer-btn" onclick="showAnswer('challenge4')"><i class="ph ph-text-aa"></i> Cevabı Göster</button>
                </div>
                <div id="hint4" class="hint"></div>
                <div id="feedback4" class="feedback"></div>
                <div id="explanation4" class="explanation">
                    <h4>Doğru Cevap! Dinamik Sistemin Sırrı.</h4>
                    <p>Bu kod bloğu, projenin anlık ve reaktif yapısının anahtarıdır.</p>
                    <ul>
                        <li><code>ws.onmessage</code>, sunucudan herhangi bir WebSocket mesajı geldiğinde otomatik olarak tetiklenir.</li>
                        <li><code>if (event.data === 'config_updated')</code>: Sadece beklenen "config_updated" mesajına tepki verildiğinden emin olunur.</li>
                        <li><code>initializeApp()</code>: Bu fonksiyon, mevcut MQTT bağlantısını keser, sunucudan en güncel ayarları (yeni topic listesi vb.) çeker ve yeni ayarlarla tekrar bağlanır. Bu, sayfa yenilemeden tam bir senkronizasyon sağlar.</li>
                    </ul>
                </div>
            </div>
        </main>
    </div>

    <script>
        const challenges = [
            {
                id: 'challenge1',
                solutionLines: [
                    '@app.get("/api/mqtt-settings")',
                    'async def get_mqtt_settings():',
                    '    config = read_config()',
                    '    return JSONResponse(content=config.get("mqtt_settings", {}), headers={"Cache-Control": "no-store"})'
                ],
                hints: [
                    "FastAPI'de bir GET isteğini karşılamak için `@app.get()` decorator'ı ile başlayın.",
                    "Fonksiyon `config.json` dosyasını `read_config()` ile okumalı.",
                    "Geriye `JSONResponse` döndürülmeli ve `headers` parametresi ile önbellek kontrolü eklenmeli."
                ]
            },
            {
                id: 'challenge2',
                solutionLines: [
                    'try:',
                    '    schema.validate(df, lazy=True)',
                    '    self.client.publish(mapping["validated"], payload=payload, retain=True)',
                    'except pa.errors.SchemaErrors as err:',
                    '    error_report = {"errors": "details...", "original_payload": data}',
                    '    error_payload = json.dumps(replace_nan_with_none(error_report))',
                    '    self.client.publish(mapping["failed"], payload=error_payload, retain=True)'
                ],
                 hints: [
                    "`try:` bloğu içinde, doğrulama (`schema.validate`) sonrası `self.client.publish` ile 'validated' konusuna yayın yapın.",
                    "`except pa.errors.SchemaErrors as err:` bloğu ile hatayı yakalayın.",
                    "`except` bloğunda, bir hata raporu oluşturun, bunu `json.dumps` ile metne çevirin ve 'failed' konusuna yayınlayın."
                ]
            },
            {
                id: 'challenge3',
                 solutionLines: [
                    'try {',
                    '    await apiCall(\'/api/topic-mappings\', { method: \'POST\', body: JSON.stringify(mappings) });',
                    '    await apiCall(\'/api/mqtt-settings\', { method: \'POST\', body: JSON.stringify(settings) });',
                    '    showStatus(configStatus, \'Configuration saved successfully!\', true);',
                    '} catch (error) {',
                    '    showStatus(configStatus, `Failed to save configuration: ${error.message}`, false);',
                    '}'
                ],
                 hints: [
                    "Bir `try-catch` bloğu ile başlayın: `try { ... } catch (error) { ... }`",
                    "`try` bloğu içine, `await` kullanarak iki `apiCall` (veya `fetch`) isteği yerleştirin.",
                    "`catch` bloğu içinde, kullanıcıya hata mesajı göstermek için `showStatus` fonksiyonunu çağırın."
                ]
            },
            {
                id: 'challenge4',
                solutionLines: [
                    'ws.onmessage = (event) => {',
                    '    if (event.data === \'config_updated\') {',
                    '        console.log(\'Configuration has changed on the server. Re-initializing...\');',
                    '        initializeApp();',
                    '    }',
                    '};'
                ],
                 hints: [
                    "WebSocket nesnesinin `onmessage` olay yöneticisini tanımlayın.",
                    "Gelen mesajın verisini `event.data` ile kontrol eden bir `if` koşulu ekleyin.",
                    "Koşul doğru olduğunda, sistemin yeniden başlatılmasını sağlayan `initializeApp()` fonksiyonunu çağırın."
                ]
            }
        ];

        let hintStates = {};
        challenges.forEach(c => hintStates[c.id] = 0);

        function normalizeCode(str) {
            return str.replace(/\s+/g, '').replace(/;$/, '');
        }

        function checkAnswer(challengeId) {
            const challenge = challenges.find(c => c.id === challengeId);
            const feedbackEl = document.getElementById(`feedback${challengeId.slice(-1)}`);
            const explanationEl = document.getElementById(`explanation${challengeId.slice(-1)}`);
            const editorEl = document.getElementById(challengeId);

            const solutionKey = normalizeCode(challenge.solutionLines.join(''));
            const userInputKey = normalizeCode(editorEl.value);

            if (userInputKey === solutionKey) {
                feedbackEl.textContent = 'Tebrikler, doğru cevap! Kodun açıklamasına aşağıdan göz atabilirsiniz.';
                feedbackEl.className = 'feedback success';
                explanationEl.style.display = 'block';
            } else {
                feedbackEl.textContent = 'Cevap tam olarak doğru değil. Lütfen tekrar deneyin veya ipucu alın.';
                feedbackEl.className = 'feedback error';
                explanationEl.style.display = 'none';
            }
            feedbackEl.style.display = 'block';
            document.getElementById(`hint${challengeId.slice(-1)}`).style.display = 'none';
        }

        function getHint(challengeId) {
            const challenge = challenges.find(c => c.id === challengeId);
            const hintEl = document.getElementById(`hint${challengeId.slice(-1)}`);
            const currentHintIndex = hintStates[challengeId];
            
            hintEl.textContent = `💡 İpucu: ${challenge.hints[currentHintIndex]}`;
            hintEl.style.display = 'block';
            
            hintStates[challengeId] = (currentHintIndex + 1) % challenge.hints.length;
        }

        function showAnswer(challengeId) {
            const challenge = challenges.find(c => c.id === challengeId);
            const editorEl = document.getElementById(challengeId);
            
            editorEl.value = challenge.solutionLines.join('\n');
            checkAnswer(challengeId);
        }

        function fixLine(challengeId) {
            const challenge = challenges.find(c => c.id === challengeId);
            const editorEl = document.getElementById(challengeId);
            const text = editorEl.value;
            const cursorPosition = editorEl.selectionStart;

            let lineStart = text.lastIndexOf('\n', cursorPosition - 1) + 1;
            let lineEnd = text.indexOf('\n', cursorPosition);
            if (lineEnd === -1) lineEnd = text.length;

            let currentLineNumber = (text.substring(0, cursorPosition).match(/\n/g) || []).length;
            
            if (challenge.solutionLines[currentLineNumber] !== undefined) {
                const correctLine = challenge.solutionLines[currentLineNumber];
                const newText = text.substring(0, lineStart) + correctLine + text.substring(lineEnd);
                editorEl.value = newText;
                editorEl.selectionStart = editorEl.selectionEnd = lineStart + correctLine.length;
                editorEl.focus();
            }
        }

        function handleEditorKeystrokes(event) {
            const editorEl = event.target;
            if (event.key === 'Tab') {
                event.preventDefault();
                const start = editorEl.selectionStart;
                const end = editorEl.selectionEnd;
                editorEl.value = editorEl.value.substring(0, start) + "    " + editorEl.value.substring(end);
                editorEl.selectionStart = editorEl.selectionEnd = start + 4;
            } else if (event.key === 'Enter') {
                event.preventDefault();
                const cursorPosition = editorEl.selectionStart;
                const textBeforeCursor = editorEl.value.substring(0, cursorPosition);
                const lineStart = textBeforeCursor.lastIndexOf('\n') + 1;
                const currentLine = textBeforeCursor.substring(lineStart);
                const indentMatch = currentLine.match(/^\s*/);
                let indent = indentMatch ? indentMatch[0] : '';

                if (currentLine.trim().endsWith(':')) {
                    indent += '    ';
                }

                const newText = `\n${indent}`;
                editorEl.value = editorEl.value.substring(0, cursorPosition) + newText + editorEl.value.substring(editorEl.selectionEnd);
                editorEl.selectionStart = editorEl.selectionEnd = cursorPosition + newText.length;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.code-editor').forEach(editor => {
                editor.addEventListener('keydown', handleEditorKeystrokes);
            });
        });
    </script>
</body>
</html> 