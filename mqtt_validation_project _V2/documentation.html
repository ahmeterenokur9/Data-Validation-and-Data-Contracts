<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proje Dokümantasyonu: Dinamik MQTT Veri Doğrulama Sistemi</title>
    <!-- Modern Font ve İkonlar -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Kod renklendirme için Prism.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-color: #2c2c2c;
            --text-color: #f0f0f0;
            --primary-color: #4ecca3;
            --secondary-color: #3b3b3b;
            --border-color: #444;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 2rem;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        header p {
            font-size: 1.2rem;
            color: #ccc;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        h2 {
            font-size: 1.8rem;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        h3 {
            font-size: 1.4rem;
            color: #ddd;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }

        code {
            background-color: var(--secondary-color);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
        }

        pre[class*="language-"] {
            padding: 1.5em;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            font-size: 0.95em;
        }

        .flowchart {
            background-color: var(--secondary-color);
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1rem;
            border: 1px dashed var(--primary-color);
        }
        
        ul {
            list-style: none;
            padding-left: 0;
        }

        li {
            background-color: var(--secondary-color);
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
        }

        li strong {
            color: var(--primary-color);
            display: block;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1><i class="ph-bold ph-rocket-launch"></i> Proje Dokümantasyonu</h1>
            <p>Dinamik MQTT Veri Doğrulama ve Görüntüleme Sistemi</p>
        </header>

        <main>
            <section class="card">
                <h2><i class="ph ph-compass"></i> Projeye Genel Bakış</h2>
                <p>
                    Bu proje, IoT (Nesnelerin İnterneti) sensörlerinden gelen verileri gerçek zamanlı olarak alan, önceden tanımlanmış kurallara (şemalara) göre doğrulayan ve sonuçları dinamik bir web arayüzünde (dashboard) sunan bir sistemdir. Projenin en temel özelliği, tüm MQTT bağlantı ayarlarının, veri doğrulama şemalarının ve veri yönlendirme kurallarının, sistemi yeniden başlatmaya gerek kalmadan, modern bir yönetim paneli üzerinden anlık olarak değiştirilebilmesidir.
                </p>
            </section>
            
            <section class="card">
                <h2><i class="ph ph-cogs"></i> Kullanılan Teknolojiler</h2>
                <ul>
                    <li>
                        <strong>FastAPI (Python Framework):</strong>
                        Projenin backend'i (sunucu tarafı) için kullanılmıştır. Yüksek performansı, modern yapısı ve otomatik Swagger UI dokümantasyonu oluşturması sayesinde tercih edilmiştir. Tüm API endpoint'leri ve WebSocket bağlantıları FastAPI üzerinden yönetilir.
                    </li>
                    <li>
                        <strong>Paho-MQTT (Python Kütüphanesi):</strong>
                        Python tarafında MQTT broker'ı ile iletişimi (mesajları almak ve göndermek) sağlayan temel kütüphanedir. <code>mqtt_manager.py</code> içinde kullanılır.
                    </li>
                    <li>
                        <strong>Pandera (Python Kütüphanesi):</strong>
                        Veri doğrulama motorudur. Gelen sensör verilerinin, <code>schemas</code> klasöründeki JSON dosyalarında tanımlanan kurallara (örneğin, sıcaklık -40 ile 85 arasında olmalı) uyup uymadığını kontrol eder.
                    </li>
                    <li>
                        <strong>Uvicorn (ASGI Sunucusu):</strong>
                        FastAPI uygulamasını çalıştırmak için kullanılan yüksek performanslı bir ASGI (Asynchronous Server Gateway Interface) sunucusudur.
                    </li>
                    <li>
                        <strong>WebSocket:</strong>
                        Sunucu ve istemci (web tarayıcısı) arasında çift yönlü ve kalıcı bir iletişim kanalı sağlar. Bu proje, yönetim panelinde yapılan bir konfigürasyon değişikliğini anında hem backend'deki MQTT istemcisine hem de dashboard'u izleyen kullanıcılara bildirmek için kullanılır.
                    </li>
                    <li>
                        <strong>HTML5 / CSS3 / JavaScript:</strong>
                        Projenin ön yüzü (Yönetim Paneli ve Dashboard) bu temel web teknolojileri ile oluşturulmuştur.
                    </li>
                     <li>
                        <strong>MQTT.js (JavaScript Kütüphanesi):</strong>
                        Web tarayıcısının (dashboard) MQTT broker'ına bağlanıp mesajları dinleyebilmesi için kullanılan JavaScript kütüphanesidir.
                    </li>
                </ul>
            </section>

            <section class="card">
                <h2><i class="ph ph-graph"></i> Mimari ve Veri Akışı</h2>
                <p>Sistem 4 ana bileşenden oluşur: Veri Yayıncıları, MQTT Broker, Backend Sunucusu (Doğrulayıcı) ve Frontend Arayüzleri.</p>

                <h3>1. Standart Veri Akışı</h3>
                <div class="flowchart">
                    Sensor Publisher ➔ MQTT Broker ➔ Backend (MQTTManager) ➔ Pandera Validator ➔ MQTT Broker ➔ Web Dashboard
                </div>
                <p>Bu akış adım adım şu şekilde işler:</p>
                <ol>
                    <li><strong>Veri Gönderimi:</strong> Bir sensör simülatörü (örn: <code>sensor1_publisher.py</code>), ham veri içeren bir JSON mesajını belirli bir "kaynak" konuya (örn: <code>/sensor1</code>) yayınlar.</li>
                    <li><strong>Veri Alımı:</strong> Backend'de çalışan <code>MQTTManager</code>, <code>config.json</code>'da tanımlı olan tüm "kaynak" konulara abone olduğu için bu mesajı anında alır.</li>
                    <li><strong>Şema ve Kural Tespiti:</strong> <code>MQTTManager</code>, gelen mesajın hangi konudan (<code>/sensor1</code>) geldiğini bilir. <code>config.json</code>'a bakarak bu konuyla ilişkili şema dosyasını (<code>schemas/sensor1.json</code>) ve yeniden yayınlanacak "geçerli" (<code>/sensor1/validated</code>) ve "hatalı" (<code>/sensor1/failed</code>) konuları bulur.</li>
                    <li><strong>Doğrulama:</strong> Mesaj içeriği, Pandera kütüphanesi kullanılarak ilgili şemaya göre kontrol edilir.</li>
                    <li><strong>Yeniden Yayınlama (Republish):</strong>
                        <ul>
                            <li><strong>Veri Geçerliyse:</strong> Orijinal mesaj, "geçerli" olarak tanımlanan konuya (<code>/sensor1/validated</code>) yeniden yayınlanır.</li>
                            <li><strong>Veri Hatalıysa:</strong> Orijinal mesaja ek olarak hatanın nedenini içeren bir rapor oluşturulur ve "hatalı" konuya (<code>/sensor1/failed</code>) yayınlanır.</li>
                        </ul>
                    </li>
                    <li><strong>Görüntüleme:</strong> Web Dashboard (<code>app.js</code>), tüm "geçerli" ve "hatalı" konulara abone olmuştur. Gelen mesajı alır ve ekranda ilgili kart olarak gösterir.</li>
                </ol>

                <h3>2. Dinamik Konfigürasyon Akışı</h3>
                 <div class="flowchart">
                    Admin Panel ➔ FastAPI API ➔ config.json &amp; WebSocket ➔ MQTTManager &amp; Web Dashboard
                </div>
                <p>Sistemin dinamik yapısı şu şekilde çalışır:</p>
                 <ol>
                    <li><strong>Değişiklik:</strong> Kullanıcı, Yönetim Paneli'nde (<code>admin.html</code>) bir ayarı (örn: bir konunun şemasını veya adını) değiştirir ve "Save Configuration" butonuna tıklar.</li>
                    <li><strong>API İsteği:</strong> Tarayıcı, FastAPI sunucusundaki ilgili API endpoint'ine (örn: <code>POST /api/topic-mappings</code>) yeni konfigürasyon verilerini gönderir.</li>
                    <li><strong>Sunucu İşlemi:</strong> <code>main.py</code> içindeki API fonksiyonu bu isteği alır ve <code>config.json</code> dosyasını günceller.</li>
                    <li><strong>Yeniden Başlatma ve Bildirim:</strong>
                        <ul>
                            <li><code>main.py</code>, backend'deki <code>MQTTManager</code>'ın güvenli bir şekilde yeniden başlatılmasını tetikler. <code>MQTTManager</code>, yeni ayarları <code>config.json</code>'dan okuyarak yeniden bağlanır ve yeni konulara abone olur.</li>
                            <li>Aynı anda <code>main.py</code>, WebSocket üzerinden tüm bağlı istemcilere (dashboard'lara) <code>"config_updated"</code> mesajı yayınlar.</li>
                        </ul>
                    </li>
                    <li><strong>İstemci Güncellemesi:</strong> Dashboard (<code>app.js</code>), bu WebSocket mesajını alır. Mevcut MQTT bağlantısını keser, sunucudan yeni konu listesini (<code>/api/topic-mappings</code>) çeker ve bu yeni konulara abone olarak MQTT broker'ına yeniden bağlanır.</li>
                </ol>
            </section>
            
            <section class="card">
                <h2><i class="ph ph-files"></i> Proje Dosyaları ve Görevleri</h2>
                <ul>
                    <li>
                        <strong><code>main.py</code></strong>
                        Backend'in kalbidir. FastAPI uygulamasını barındırır. Görevleri:
                        <ul>
                            <li>Statik dosyaları (HTML, CSS, JS) sunmak.</li>
                            <li>Tüm API endpoint'lerini (<code>/api/mqtt-settings</code>, <code>/api/schemas</code>, vb.) tanımlamak.</li>
                            <li>WebSocket (<code>/ws/config-updates</code>) bağlantılarını yönetmek.</li>
                            <li>Uygulama başladığında <code>MQTTManager</code>'ı başlatmak ve ayar değişikliğinde yeniden başlatmak.</li>
                        </ul>
                        <pre><code class="language-python"># Örnek: Topic Mappings güncelleme endpoint'i
@app.post("/api/topic-mappings")
async def update_topic_mappings(mappings: List[TopicMapping]):
    config = read_config()
    config["topic_mappings"] = [m.dict() for m in mappings]
    write_config(config)
    restart_mqtt_client()  # MQTT istemcisini yeniden başlat
    await manager.broadcast("config_updated") # Değişikliği duyur
    return {"message": "Topic mappings updated successfully."}
</code></pre>
                    </li>
                    <li>
                        <strong><code>mqtt_manager.py</code></strong>
                        Tüm MQTT operasyonlarını yöneten sınıftır. Arka planda ayrı bir thread'de çalışarak web sunucusunu bloklamaz. Görevleri:
                        <ul>
                            <li>MQTT broker'ına bağlanmak.</li>
                            <li><code>config.json</code>'daki "kaynak" konulara abone olmak.</li>
                            <li>Gelen mesajları Pandera ile doğrulamak.</li>
                            <li>Sonuçları "geçerli" veya "hatalı" konulara yeniden yayınlamak.</li>
                        </ul>
                         <pre><code class="language-python"># Örnek: Mesaj işleme mantığı
def on_message(self, client, userdata, msg):
    # ...
    # config'den doğru mapping'i bul
    # ...
    try:
        # Pandera ile veriyi doğrula
        schema.validate(df, lazy=True)
        # Geçerli konuya yayınla
        self.client.publish(mapping["validated"], payload=payload, retain=True)
    except pa.errors.SchemaErrors as err:
        # Hatalı konuya hata raporuyla yayınla
        self.client.publish(mapping["failed"], payload=error_payload, retain=True)
</code></pre>
                    </li>
                    <li>
                        <strong><code>config.json</code></strong>
                        Sistemin "tek doğruluk kaynağıdır". Tüm dinamik ayarlar burada saklanır. Değiştirildiğinde tüm sistem kendini buna göre ayarlar.
                         <pre><code class="language-json">{
  "mqtt_settings": {
    "broker": "broker.hivemq.com",
    "port": 1883
  },
  "topic_mappings": [
    {
      "source": "/sensor1",
      "validated": "/sensor1/validated",
      "failed": "/sensor1/failed",
      "schema": "schemas/sensor1.json"
    }
  ]
}</code></pre>
                    </li>
                    <li>
                        <strong><code>static/admin.html</code> ve <code>static/admin.css</code></strong>
                        Yönetim Panelini oluşturan dosyalardır. Kullanıcıların tüm sistem ayarlarını (MQTT, Konu Eşlemeleri, Şemalar) değiştirmesini sağlayan arayüzü ve mantığı içerir. Değişiklikler, FastAPI API'sine yapılan isteklerle sunucuya gönderilir.
                    </li>
                    <li>
                        <strong><code>static/dashboard.html</code> ve <code>static/app.js</code></strong>
                        Veri Görüntüleme Panelini (Dashboard) oluşturan dosyalardır. <code>app.js</code>, MQTT broker'ına bağlanır, gelen doğrulanmış/hatalı verileri dinler, ekranda kartlar halinde gösterir ve dinamik filtreleme mantığını içerir. Ayrıca, WebSocket üzerinden gelen konfigürasyon değişikliklerine göre kendini otomatik olarak günceller.
                         <pre><code class="language-javascript">// Örnek: app.js'de WebSocket dinleyicisi
ws.onmessage = (event) => {
    if (event.data === 'config_updated') {
        console.log('Configuration has changed...');
        // initializeApp fonksiyonu MQTT bağlantısını kesip
        // yeni ayarlarla yeniden kurar.
        initializeApp();
    }
};</code></pre>
                    </li>
                </ul>
            </section>

            <section class="card">
                <h2><i class="ph ph-list-checks"></i> Adım Adım Kullanım Senaryoları</h2>
                <p>
                    Bu bölümde, sistemin temel işlevlerinin arka planda nasıl çalıştığı adım adım, ilgili kod parçalarıyla açıklanmaktadır.
                </p>

                <h3>Senaryo 1: Yönetim Panelinden Bir Konu (Topic) Ayarını Değiştirmek</h3>
                <p><strong>Amaç:</strong> <code>/sensor3</code> konusundan gelen verilerin artık <code>schemas/sensor3.json</code> yerine <code>schemas/yeni.json</code> şeması ile doğrulanmasını ve geçerli verilerin <code>/sensor3/gecerli</code> konusuna yayınlanmasını sağlamak.</p>
                <ol>
                    <li>
                        <strong>Adım 1: Kullanıcı Arayüzü (<code>admin.html</code>)</strong><br>
                        Kullanıcı, "Topic Mappings" altındaki ilgili girdileri değiştirir ve "Save Configuration" butonuna tıklar.
                    </li>
                    <li>
                        <strong>Adım 2: API İsteği Gönderimi (<code>admin.html</code>)</strong><br>
                        Butona tıklandığında, JavaScript tüm form verilerini toplar ve <code>/api/topic-mappings</code> ile <code>/api/mqtt-settings</code> adreslerine <code>POST</code> isteği gönderir.
                        <pre><code class="language-javascript">// admin.html
document.getElementById('mqtt-config-form').addEventListener('submit', async (e) => {
    // ... form verileri toplanır ...
    const mappings = [...]; 
    const settings = {...};

    // Sunucuya yeni ayarlar gönderilir
    await apiCall('/api/topic-mappings', { method: 'POST', ..., body: JSON.stringify(mappings) });
    await apiCall('/api/mqtt-settings', { method: 'POST', ..., body: JSON.stringify(settings) });
    // ...
});</code></pre>
                    </li>
                    <li>
                        <strong>Adım 3: Sunucu Tarafı - Ayarların Kaydedilmesi (<code>main.py</code>)</strong><br>
                        FastAPI, bu isteği yakalar ve ilgili endpoint fonksiyonunu çalıştırır. Bu fonksiyon, gelen yeni verilerle <code>config.json</code> dosyasını günceller.
                        <pre><code class="language-python"># main.py
@app.post("/api/topic-mappings")
async def update_topic_mappings(mappings: List[TopicMapping]):
    config = read_config()
    config["topic_mappings"] = [m.dict() for m in mappings]
    write_config(config) # config.json diske yazılır
    # ...
    return {"message": "Topic mappings updated successfully."}</code></pre>
                    </li>
                    <li>
                        <strong>Adım 4: Sunucu Tarafı - MQTT İstemcisinin Yeniden Başlatılması (<code>main.py</code>)</strong><br>
                        <code>config.json</code> güncellendikten sonra, <code>main.py</code> içindeki <code>restart_mqtt_client()</code> fonksiyonu çağrılır. Bu fonksiyon, mevcut <code>MQTTManager</code> thread'ini durdurur ve en güncel <code>config.json</code> ayarlarıyla yeniden başlatır.
                         <pre><code class="language-python"># main.py
def restart_mqtt_client():
    global mqtt_client, mqtt_thread
    if mqtt_client:
        print("Stopping existing MQTT client...")
        mqtt_client.stop()
        mqtt_thread.join()
    
    print("Starting MQTT client with updated config...")
    # ... Yeni istemci güncel ayarlarla başlatılır ...</code></pre>
                    </li>
                    <li>
                        <strong>Adım 5: Sunucu Tarafı - WebSocket Bildirimi (<code>main.py</code>)</strong><br>
                        Ayar değişikliği kaydedildikten hemen sonra sunucu, WebSocket üzerinden bağlı olan tüm istemcilere (tüm açık Dashboard'lara) <code>"config_updated"</code> mesajı gönderir.
                        <pre><code class="language-python"># main.py - update_topic_mappings içinde
    await manager.broadcast("config_updated") # Değişiklik tüm istemcilere duyurulur
</code></pre>
                    </li>
                    <li>
                        <strong>Adım 6: İstemci Tarafı - Bildirimin Alınması (<code>app.js</code>)</strong><br>
                        Dashboard'un JavaScript kodu, bu WebSocket mesajını alır.
                         <pre><code class="language-javascript">// app.js
ws.onmessage = (event) => {
    if (event.data === 'config_updated') {
        console.log('Configuration has changed on the server. Re-initializing...');
        initializeApp(); // Yeniden başlatma fonksiyonu tetiklenir
    }
};</code></pre>
                    </li>
                     <li>
                        <strong>Adım 7: İstemci Tarafı - Dashboard'un Kendini Güncellemesi (<code>app.js</code>)</strong><br>
                        <code>initializeApp()</code> fonksiyonu, mevcut MQTT bağlantısını keser, sunucudan <code>/api/topic-mappings</code> endpoint'i üzerinden yeni konu listesini (içinde <code>/sensor3/gecerli</code> olan) çeker ve bu yeni konulara abone olarak broker'a yeniden bağlanır. Ayrıca kenar çubuğundaki filtreleri de günceller. Bu sayede tüm sistem, yeniden başlatmaya gerek kalmadan yeni ayarlarla çalışmaya devam eder.
                    </li>
                </ol>

                <h3>Senaryo 2: Geçerli Bir Sensör Verisinin İşlenmesi</h3>
                <ol>
                    <li><strong>Adım 1: Veri Yayını (<code>sensor1_publisher.py</code>)</strong><br>Publisher, geçerli bir veri paketini <code>/sensor1</code> konusuna yayınlar.</li>
                    <li><strong>Adım 2: Veri Alımı (<code>mqtt_manager.py</code>)</strong><br><code>MQTTManager</code>, <code>/sensor1</code> konusuna abone olduğu için mesajı anında alır.</li>
                    <li><strong>Adım 3: Kural Tespiti (<code>mqtt_manager.py</code>)</strong><br>Gelen konunun <code>/sensor1</code> olduğunu anlar ve <code>config.json</code>'dan bu konu için kullanılacak şemanın <code>schemas/sensor1.json</code>, geçerli topic'in <code>/sensor1/validated</code> olduğunu bulur.</li>
                    <li><strong>Adım 4: Başarılı Doğrulama (Pandera)</strong><br>Mesaj içeriği, <code>sensor1.json</code> şemasına göre kontrol edilir ve hiçbir hata bulunmaz.</li>
                    <li><strong>Adım 5: Yeniden Yayınlama (<code>mqtt_manager.py</code>)</strong><br>Doğrulama başarılı olduğu için, orijinal mesaj <code>/sensor1/validated</code> konusuna yeniden yayınlanır.</li>
                    <li><strong>Adım 6: Dashboard'da Görüntüleme (<code>app.js</code>)</strong><br>Dashboard, <code>/sensor1/validated</code> konusuna abone olduğu için mesajı alır ve ekranda yeşil renkli, "validated" bir kart olarak gösterir.</li>
                </ol>

                <h3>Senaryo 3: Hatalı Bir Sensör Verisinin İşlenmesi</h3>
                <ol>
                    <li><strong>Adım 1: Hatalı Veri Yayını (<code>sensor2_publisher.py</code>)</strong><br>Publisher, içinde <code>"altitude"</code> yerine <code>"acceleration"</code> gibi yanlış bir alan adı olan veya değeri aralık dışında olan bir mesajı <code>/sensor2</code> konusuna yayınlar.</li>
                    <li><strong>Adım 2: Veri Alımı (<code>mqtt_manager.py</code>)</strong><br><code>MQTTManager</code>, <code>/sensor2</code>'den mesajı alır.</li>
                    <li><strong>Adım 3: Başarısız Doğrulama (Pandera)</strong><br>Mesaj, <code>schemas/sensor2.json</code> şemasına göre kontrol edilir. Pandera, şemada olmayan <code>"acceleration"</code> alanından dolayı bir <code>SchemaError</code> hatası fırlatır.</li>
                    <li><strong>Adım 4: Hata Raporu Oluşturma (<code>mqtt_manager.py</code>)</strong><br><code>except</code> bloğu çalışır. Hatanın detaylarını (örn: "Ekstra alan bulundu") ve orijinal mesajı içeren yeni bir JSON hata raporu oluşturulur.</li>
                    <li><strong>Adım 5: Hatalı Konuya Yayınlama (<code>mqtt_manager.py</code>)</strong><br>Oluşturulan bu detaylı hata raporu, <code>config.json</code>'da tanımlı olan <code>/sensor2/failed</code> konusuna yayınlanır.</li>
                    <li><strong>Adım 6: Dashboard'da Görüntüleme (<code>app.js</code>)</strong><br>Dashboard, <code>/sensor2/failed</code> konusundan gelen hata raporunu alır ve ekranda kırmızı renkli, "failed" bir kart olarak, hatanın detaylarıyla birlikte gösterir.</li>
                </ol>

                <h3>Senaryo 4: Yeni Bir Şema Dosyası Oluşturma</h3>
                 <ol>
                    <li><strong>Adım 1: Arayüz (<code>admin.html</code>)</strong><br>Kullanıcı, "Schema File Editor" bölümünde "Create New" butonuna tıklar, dosya adını (örn: <code>sensor4.json</code>) ve içeriğini girip "Save Schema File" butonuna basar.</li>
                    <li><strong>Adım 2: API İsteği (<code>admin.html</code> -> <code>main.py</code>)</strong><br>JavaScript, bu bir "oluşturma" işlemi olduğu için, dosya adı ve içeriğini içeren bir <code>POST</code> isteğini <code>/api/schemas</code> adresine gönderir.
                        <pre><code class="language-javascript">// admin.html
const url = isEditMode ? `/api/schemas/${currentEditingFilename}` : '/api/schemas';
const method = isEditMode ? 'PUT' : 'POST';
const body = isEditMode ? content : { filename, content };
await apiCall(url, { method, ..., body: JSON.stringify(body) });
</code></pre>
                    </li>
                    <li><strong>Adım 3: Sunucu - Dosya Oluşturma (<code>main.py</code>)</strong><br>FastAPI'deki <code>create_new_schema_file</code> fonksiyonu bu isteği karşılar, dosya adının geçerli olup olmadığını kontrol eder ve <code>schemas/</code> dizini altına yeni dosyayı fiziksel olarak oluşturur.
                        <pre><code class="language-python"># main.py
@app.post("/api/schemas", status_code=201)
async def create_new_schema_file(item: SchemaFile):
    file_path = SCHEMAS_DIR / item.filename
    # ... güvenlik kontrolleri ...
    with open(file_path, "w") as f:
        json.dump(item.content, f, indent=2)
    return {"message": f"Schema file '{item.filename}' created."}
</code></pre>
                    </li>
                    <li><strong>Adım 4: Arayüzün Güncellenmesi (<code>admin.html</code>)</strong><br>Kaydetme işlemi başarılı olduktan sonra, JavaScript <code>loadInitialConfig()</code> fonksiyonunu tekrar çağırır. Bu fonksiyon, <code>/api/schemas</code>'dan güncel dosya listesini çeker ve hem "Available Schemas" tablosunu hem de "Topic Mappings" bölümündeki şema seçim kutularını yeni eklenen <code>sensor4.json</code> seçeneği ile günceller.</li>
                </ol>
            </section>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 